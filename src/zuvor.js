// Generated by CoffeeScript 1.8.0
var __hasProp = {}.hasOwnProperty;

(function() {
  var Dag, Node, Set, isObjectEmpty, zuvor;
  isObjectEmpty = function(x) {
    var v;
    for (v in x) {
      if (!__hasProp.call(x, v)) continue;
      return false;
    }
    return true;
  };
  Set = function(other) {
    this._map = Object.create(null);
    this.length = 0;
    if (other != null) {
      this.add(other);
    }
    return this;
  };
  Set.prototype = {
    isIn: function(x) {
      return this._map[x] != null;
    },
    isEmpty: function() {
      return this.length === 0;
    },
    isEqual: function(other) {
      var that;
      that = this;
      return that.length === other.length && other.elements().every(function(x) {
        return that.isIn(x);
      });
    },
    toString: function() {
      return '#{' + Object.keys(this._map).join(' ') + '}';
    },
    elements: function() {
      var elements, k, v, _ref;
      elements = [];
      _ref = this._map;
      for (k in _ref) {
        v = _ref[k];
        if (v) {
          elements.push(k);
        }
      }
      return elements;
    },
    add: function(other) {
      var key, type, v, _i, _len;
      type = typeof other;
      if (type === 'string' || type === 'number') {
        if (!this.isIn(other)) {
          this._map[other] = true;
          this.length++;
        }
      } else if (other instanceof Set) {
        for (key in other._map) {
          if (!this.isIn(key)) {
            this._map[key] = true;
            this.length++;
          }
        }
      } else if (Array.isArray(other)) {
        for (_i = 0, _len = other.length; _i < _len; _i++) {
          v = other[_i];
          if (!this.isIn(v)) {
            this._map[v] = true;
            this.length++;
          }
        }
      } else {
        throw new TypeError('unsupported argument type');
      }
      return this;
    },
    remove: function(other) {
      var key, type, v, _i, _len;
      type = typeof other;
      if (type === 'string' || type === 'number') {
        if (this.isIn(other)) {
          this._map[other] = void 0;
          this.length--;
        }
      } else if (other instanceof Set) {
        for (key in other._map) {
          if (this.isIn(key)) {
            this._map[key] = void 0;
            this.length--;
          }
        }
      } else if (Array.isArray(other)) {
        for (_i = 0, _len = other.length; _i < _len; _i++) {
          v = other[_i];
          if (this.isIn(v)) {
            this._map[v] = void 0;
            this.length--;
          }
        }
      } else {
        throw new TypeError('unsupported argument type');
      }
      return this;
    },
    clone: function() {
      return new Set(this);
    }
  };
  Node = function(value) {
    this.value = value;
    this.parents = Object.create(null);
    this.children = Object.create(null);
    return this;
  };
  Node.prototype = {
    addParent: function(node) {
      return this.parents[node.value] = node;
    },
    addChild: function(node) {
      return this.children[node.value] = node;
    }
  };
  Dag = function() {
    this.nodes = Object.create(null);
    return this;
  };
  Dag.prototype = {};
  Dag.prototype.before = function(a, b) {
    var nodeA, nodeB, typeA, typeB;
    typeA = typeof a;
    if (!(typeA === 'string' || typeA === 'number')) {
      throw new TypeError("argument a must be a string or number but is " + typeA);
    }
    typeB = typeof b;
    if (!(typeB === 'string' || typeB === 'number')) {
      throw new TypeError("argument b must be a string or number but is " + typeB);
    }
    if (a === b) {
      throw new Error('arguments must not be equal');
    }
    if (this.isBefore(b, a)) {
      throw new Error("trying to set `" + a + "` -> `" + b + "` but already `" + b + "` -> `" + a + "`");
    }
    nodeA = this.nodes[a];
    if (nodeA == null) {
      nodeA = new Node(a);
      this.nodes[a] = nodeA;
    }
    nodeB = this.nodes[b];
    if (nodeB == null) {
      nodeB = new Node(b);
      this.nodes[b] = nodeB;
    }
    nodeA.addChild(nodeB);
    nodeB.addParent(nodeA);
    return this;
  };
  Dag.prototype.isIn = function(x) {
    return this.nodes[x] != null;
  };
  Dag.prototype.isBefore = function(a, b) {
    var child, key, nextNodes, node, nodeA, nodeB, nodes, that, _i, _len, _ref;
    that = this;
    nodeA = this.nodes[a];
    nodeB = this.nodes[b];
    if ((nodeA == null) || (nodeB == null)) {
      return false;
    }
    nodes = [nodeA];
    while (nodes.length !== 0) {
      nextNodes = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        if (node.children[b] != null) {
          return true;
        }
        _ref = node.children;
        for (key in _ref) {
          child = _ref[key];
          nextNodes.push(child);
        }
      }
      nodes = nextNodes;
    }
    return false;
  };
  Dag.prototype.elements = function() {
    var elements, key, node, _ref;
    elements = [];
    _ref = this.nodes;
    for (key in _ref) {
      node = _ref[key];
      elements.push(node.value);
    }
    return elements;
  };
  Dag.prototype.parentless = function() {
    var elements, key, node, _ref;
    elements = [];
    _ref = this.nodes;
    for (key in _ref) {
      node = _ref[key];
      if (isObjectEmpty(node.parents)) {
        elements.push(node.value);
      }
    }
    return elements;
  };
  Dag.prototype.childless = function() {
    var elements, key, node, _ref;
    elements = [];
    _ref = this.nodes;
    for (key in _ref) {
      node = _ref[key];
      if (isObjectEmpty(node.children)) {
        elements.push(node.value);
      }
    }
    return elements;
  };
  Dag.prototype.whereAllParentsIn = function(xs) {
    var allParentsIn, child, k, key, node, parentValue, resultSet, results, v, x, xsSet, _i, _j, _len, _len1, _ref;
    xsSet = Object.create(null);
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      xsSet[x] = true;
    }
    resultSet = Object.create(null);
    for (_j = 0, _len1 = xs.length; _j < _len1; _j++) {
      x = xs[_j];
      node = this.nodes[x];
      if (node == null) {
        throw new Error("searching whereAllParentsIn of `" + x + "` which is not in graph");
      }
      _ref = node.children;
      for (key in _ref) {
        child = _ref[key];
        if (resultSet[key] != null) {
          continue;
        }
        if (xsSet[key] != null) {
          continue;
        }
        allParentsIn = true;
        for (parentValue in child.parents) {
          if (xsSet[parentValue] == null) {
            allParentsIn = false;
            break;
          }
        }
        resultSet[key] = allParentsIn;
      }
    }
    results = [];
    for (k in resultSet) {
      v = resultSet[k];
      if (v) {
        results.push(this.nodes[k].value);
      }
    }
    return results;
  };
  Dag.prototype.whereAllChildrenIn = function(xs) {
    var allChildrenIn, childValue, k, key, node, parent, resultSet, results, v, x, xsSet, _i, _j, _len, _len1, _ref;
    xsSet = Object.create(null);
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      xsSet[x] = true;
    }
    resultSet = Object.create(null);
    for (_j = 0, _len1 = xs.length; _j < _len1; _j++) {
      x = xs[_j];
      node = this.nodes[x];
      if (node == null) {
        throw new Error("searching whereAllChildrenIn of `" + x + "` which is not in graph");
      }
      _ref = node.parents;
      for (key in _ref) {
        parent = _ref[key];
        if (resultSet[key] != null) {
          continue;
        }
        if (xsSet[key] != null) {
          continue;
        }
        allChildrenIn = true;
        for (childValue in parent.children) {
          if (xsSet[childValue] == null) {
            allChildrenIn = false;
            break;
          }
        }
        resultSet[key] = allChildrenIn;
      }
    }
    results = [];
    for (k in resultSet) {
      v = resultSet[k];
      if (v) {
        results.push(this.nodes[k].value);
      }
    }
    return results;
  };
  zuvor = {
    Dag: Dag,
    Set: Set
  };
  if (typeof window !== "undefined" && window !== null) {
    return window.zuvor = zuvor;
  } else if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    return module.exports = zuvor;
  } else {
    throw new Error('either the `window` global or the `module.exports` global must be present');
  }
})();
