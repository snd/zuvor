// Generated by CoffeeScript 1.8.0
var __hasProp = {}.hasOwnProperty,
  __slice = [].slice;

(function() {
  var Graph, Node, Promise, Set, isObjectEmpty, isThenable, zuvor;
  zuvor = {};
  if (typeof window !== "undefined" && window !== null) {
    if (window.Promise == null) {
      throw new Error('zuvor requires Promise global by bluebird to be present');
    }
    window.zuvor = zuvor;
  } else if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    Promise = require('bluebird');
    module.exports = zuvor;
  } else {
    throw new Error('either the `window` global or the `module.exports` global must be present');
  }
  isObjectEmpty = function(x) {
    var v;
    for (v in x) {
      if (!__hasProp.call(x, v)) continue;
      return false;
    }
    return true;
  };
  isThenable = function(x) {
    return x === Object(x) && 'function' === typeof x.then;
  };
  zuvor.Set = Set = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this._map = Object.create(null);
    this.size = 0;
    if (args.length !== 0) {
      this.add.apply(this, args);
    }
    return this;
  };
  Set.prototype = {
    has: function(x) {
      return this._map[x] != null;
    },
    equals: function(other) {
      var that;
      if (Array.isArray(other)) {
        other = new Set(other);
      }
      if (!(other instanceof Set)) {
        throw new TypeError('argument must be a set or array');
      }
      that = this;
      return that.size === other.size && other.keys().every(function(x) {
        return that.has(x);
      });
    },
    toString: function() {
      return '#{' + this.keys().join(' ') + '}';
    },
    keys: function() {
      var elements, k, v, _ref;
      elements = [];
      _ref = this._map;
      for (k in _ref) {
        v = _ref[k];
        if (v) {
          elements.push(k);
        }
      }
      return elements;
    },
    forEach: function(f) {
      var k, v, _ref, _results;
      _ref = this._map;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if (v) {
          _results.push(f(k));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    add: function() {
      var arg, args, that, type, v, _i, _j, _len, _len1;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        type = typeof arg;
        if (type === 'string' || type === 'number') {
          if (!this.has(arg)) {
            this._map[arg] = true;
            this.size++;
          }
        } else if (arg instanceof Set) {
          that = this;
          arg.forEach(function(x) {
            if (!that.has(x)) {
              that._map[x] = true;
              return that.size++;
            }
          });
        } else if (Array.isArray(arg)) {
          for (_j = 0, _len1 = arg.length; _j < _len1; _j++) {
            v = arg[_j];
            if (!this.has(v)) {
              this._map[v] = true;
              this.size++;
            }
          }
        } else {
          throw new TypeError('unsupported argument type');
        }
      }
      return this;
    },
    "delete": function() {
      var arg, args, that, type, v, _i, _j, _len, _len1;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        type = typeof arg;
        if (type === 'string' || type === 'number') {
          if (this.has(arg)) {
            this._map[arg] = void 0;
            this.size--;
          }
        } else if (arg instanceof Set) {
          that = this;
          arg.forEach(function(x) {
            if (that.has(x)) {
              that._map[x] = void 0;
              return that.size--;
            }
          });
        } else if (Array.isArray(arg)) {
          for (_j = 0, _len1 = arg.length; _j < _len1; _j++) {
            v = arg[_j];
            if (this.has(v)) {
              this._map[v] = void 0;
              this.size--;
            }
          }
        } else {
          throw new TypeError('unsupported argument type');
        }
      }
      return this;
    },
    clear: function() {
      this._map = Object.create(null);
      this.size = 0;
      return this;
    },
    clone: function() {
      return new Set(this);
    }
  };
  Set.prototype.values = Set.prototype.keys;
  Node = function(value) {
    this.value = value;
    this.parents = Object.create(null);
    this.children = Object.create(null);
    return this;
  };
  Node.prototype = {
    addParent: function(node) {
      return this.parents[node.value] = node;
    },
    addChild: function(node) {
      return this.children[node.value] = node;
    }
  };
  zuvor.Graph = Graph = function() {
    this.nodes = Object.create(null);
    return this;
  };
  Graph.prototype = {};
  Graph.prototype.add = function(a, b) {
    var nodeA, nodeB, typeA, typeB;
    typeA = typeof a;
    if (!(typeA === 'string' || typeA === 'number')) {
      throw new TypeError("first argument must be a string or number but is " + typeA);
    }
    typeB = typeof b;
    if (!(typeB === 'string' || typeB === 'number')) {
      throw new TypeError("second argument must be a string or number but is " + typeB);
    }
    if (a === b) {
      throw new Error('arguments must not be equal');
    }
    if (this.has(b, a)) {
      throw new Error("trying to set `" + a + "` -> `" + b + "` but already `" + b + "` -> `" + a + "`");
    }
    nodeA = this.nodes[a];
    if (nodeA == null) {
      nodeA = new Node(a);
      this.nodes[a] = nodeA;
    }
    nodeB = this.nodes[b];
    if (nodeB == null) {
      nodeB = new Node(b);
      this.nodes[b] = nodeB;
    }
    nodeA.addChild(nodeB);
    nodeB.addParent(nodeA);
    return this;
  };
  Graph.prototype.has = function(a, b) {
    var child, key, nextNodes, node, nodeA, nodeB, nodes, that, _i, _len, _ref;
    if (b == null) {
      return this.nodes[a] != null;
    }
    that = this;
    nodeA = this.nodes[a];
    nodeB = this.nodes[b];
    if ((nodeA == null) || (nodeB == null)) {
      return false;
    }
    nodes = [nodeA];
    while (nodes.length !== 0) {
      nextNodes = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        if (node.children[b] != null) {
          return true;
        }
        _ref = node.children;
        for (key in _ref) {
          child = _ref[key];
          nextNodes.push(child);
        }
      }
      nodes = nextNodes;
    }
    return false;
  };
  Graph.prototype.keys = function() {
    var key, keys, node, _ref;
    keys = [];
    _ref = this.nodes;
    for (key in _ref) {
      node = _ref[key];
      keys.push(node.value);
    }
    return keys;
  };
  Graph.prototype.edges = function() {
    var child, edges, key, node, _ref, _ref1;
    edges = [];
    _ref = this.nodes;
    for (key in _ref) {
      node = _ref[key];
      _ref1 = node.children;
      for (key in _ref1) {
        child = _ref1[key];
        edges.push([node.value, child.value]);
      }
    }
    return edges;
  };
  Graph.prototype.parents = function(x) {
    var elements, key, node, parent, _ref;
    node = this.nodes[x];
    if (node == null) {
      return [];
    }
    elements = [];
    _ref = this.nodes[x].parents;
    for (key in _ref) {
      parent = _ref[key];
      elements.push(parent.value);
    }
    return elements;
  };
  Graph.prototype.children = function(x) {
    var child, elements, key, node, _ref;
    node = this.nodes[x];
    if (node == null) {
      return [];
    }
    elements = [];
    _ref = this.nodes[x].children;
    for (key in _ref) {
      child = _ref[key];
      elements.push(child.value);
    }
    return elements;
  };
  Graph.prototype.parentless = function() {
    var elements, key, node, _ref;
    elements = [];
    _ref = this.nodes;
    for (key in _ref) {
      node = _ref[key];
      if (isObjectEmpty(node.parents)) {
        elements.push(node.value);
      }
    }
    return elements;
  };
  Graph.prototype.childless = function() {
    var elements, key, node, _ref;
    elements = [];
    _ref = this.nodes;
    for (key in _ref) {
      node = _ref[key];
      if (isObjectEmpty(node.children)) {
        elements.push(node.value);
      }
    }
    return elements;
  };
  Graph.prototype.whereAllParentsIn = function() {
    var k, resultSet, results, that, v, x, xs, _i, _len;
    xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (!(xs instanceof Set)) {
      xs = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Set, xs, function(){});
    }
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      xsSet[x] = true;
    }
    resultSet = Object.create(null);
    that = this;
    xs.forEach(function(x) {
      var allParentsIn, child, key, node, parentValue, _ref, _results;
      node = that.nodes[x];
      if (node == null) {
        throw new Error("searching whereAllParentsIn of `" + x + "` which is not in graph");
      }
      _ref = node.children;
      _results = [];
      for (key in _ref) {
        child = _ref[key];
        if (resultSet[key] != null) {
          continue;
        }
        if (xs.has(key)) {
          continue;
        }
        allParentsIn = true;
        for (parentValue in child.parents) {
          if (!xs.has(parentValue)) {
            allParentsIn = false;
            break;
          }
        }
        _results.push(resultSet[key] = allParentsIn);
      }
      return _results;
    });
    results = [];
    for (k in resultSet) {
      v = resultSet[k];
      if (v) {
        results.push(this.nodes[k].value);
      }
    }
    return results;
  };
  Graph.prototype.whereAllChildrenIn = function() {
    var k, resultSet, results, that, v, xs;
    xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (!(xs instanceof Set)) {
      xs = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Set, xs, function(){});
    }
    resultSet = Object.create(null);
    that = this;
    xs.forEach(function(x) {
      var allChildrenIn, childValue, key, node, parent, _ref, _results;
      node = that.nodes[x];
      if (node == null) {
        throw new Error("searching whereAllChildrenIn of `" + x + "` which is not in graph");
      }
      _ref = node.parents;
      _results = [];
      for (key in _ref) {
        parent = _ref[key];
        if (resultSet[key] != null) {
          continue;
        }
        if (xs.has(key)) {
          continue;
        }
        allChildrenIn = true;
        for (childValue in parent.children) {
          if (!xs.has(childValue)) {
            allChildrenIn = false;
            break;
          }
        }
        _results.push(resultSet[key] = allChildrenIn);
      }
      return _results;
    });
    results = [];
    for (k in resultSet) {
      v = resultSet[k];
      if (v) {
        results.push(this.nodes[k].value);
      }
    }
    return results;
  };
  Graph.prototype.values = Graph.prototype.keys;
  return zuvor.run = function(options) {
    var orderedPromise, orderless, orderlessPromise, results, start;
    if ('function' !== typeof options.callback) {
      throw new TypeError('options.callback must be a Function');
    }
    if (options.done == null) {
      options.done = new Set;
    }
    if (!(options.done instanceof Set)) {
      throw new TypeError('options.done must be a Set');
    }
    if (options.pending == null) {
      options.pending = new Set;
    }
    if (!(options.pending instanceof Set)) {
      throw new TypeError('options.pending must be a Set');
    }
    if ((options.graph != null) && !options.graph instanceof Graph) {
      throw new TypeError('options.graph must be a Graph');
    }
    if (options.strict == null) {
      options.strict = false;
    }
    if (options.reversed == null) {
      options.reversed = false;
    }
    if ((options.debug != null) && !'function' === typeof options.debug) {
      throw new TypeError('options.debug must be a Function');
    }
    results = {};
    orderless = new Set(options.ids)["delete"](options.graph.keys()).keys();
    options.pending.add(orderless);
    orderlessPromise = Promise.all(orderless.map(function(id) {
      var promise;
      promise = Promise.resolve(options.callback(id));
      return promise.then(function(value) {
        options.pending["delete"](id);
        options.done.add(id);
        return results[id] = value;
      });
    }));
    start = function(names) {
      var valid;
      valid = new Set(names)["delete"](options.pending)["delete"](options.done);
      options.pending.add(valid);
      return Promise.all(valid.keys().map(function(id) {
        var parent, parents, promise, values, _i, _len;
        parents = options.graph.parents(id);
        if (parents.length === 0) {
          promise = Promise.resolve(options.callback(id));
        } else {
          values = {};
          for (_i = 0, _len = parents.length; _i < _len; _i++) {
            parent = parents[_i];
            values[parent] = results[parent];
          }
          promise = Promise.resolve(options.callback(id, values));
        }
        return promise.then(function(value) {
          var candidates, keys, next;
          options.pending["delete"](id);
          options.done.add(id);
          results[id] = value;
          keys = new Set(options.done.keys())["delete"](orderless);
          candidates = options.reversed ? options.graph.whereAllChildrenIn(keys) : options.graph.whereAllParentsIn(keys);
          next = new Set(candidates)["delete"](options.pending)["delete"](options.done).keys();
          return start(next);
        });
      }));
    };
    orderedPromise = start(options.reversed ? options.graph.childless() : options.graph.parentless());
    return Promise.all([orderlessPromise, orderedPromise]).then(function() {
      return results;
    });
  };
})();
